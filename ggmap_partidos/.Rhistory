tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE)
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE)
# Simulate Intermittent demand
library(tsintermittent)
library(dplyr)
library(markovchain)
compu <- "MAC"               # Are you running the code in Windows or Mac?
if (compu == "PC") {
Sys.setenv(R_ZIPCMD= "C:/Rtools/bin/zip")
dpath <- "C:/Users/L01032102/Google Drive/Capacitacion/6S Green Belt/SPINVI"
} else {
dpath <- "/Users/Pach/Google Drive/Capacitacion/6S Green Belt/SPINVI"
}
load(file = paste(dpath, "/Datos/R/tbml.RData", sep=""))
load(file = paste(dpath, "/Datos/R/tbio.RData", sep=""))
#############################################
# Functions
#############################################
#**********************************************
# Spare Part ID
#**********************************************
ID0 <- 3200
dftsnz <- filter(tbio, ID == ID0 & Movement == "OUT") %>% arrange(Date)
ldays <- seq(min(dftsnz$Date), max(dftsnz$Date), by = "day")
tsid0 <- data.frame(Quantity = rep(0, length(ldays)))
rownames(tsid0) <- as.character(ldays)
tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE)
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE)
# Simulate Intermittent demand
library(tsintermittent)
library(dplyr)
library(markovchain)
compu <- "MAC"               # Are you running the code in Windows or Mac?
if (compu == "PC") {
Sys.setenv(R_ZIPCMD= "C:/Rtools/bin/zip")
dpath <- "C:/Users/L01032102/Google Drive/Capacitacion/6S Green Belt/SPINVI"
} else {
dpath <- "/Users/Pach/Google Drive/Capacitacion/6S Green Belt/SPINVI"
}
load(file = paste(dpath, "/Datos/R/tbml.RData", sep=""))
load(file = paste(dpath, "/Datos/R/tbio.RData", sep=""))
#############################################
# Functions
#############################################
#**********************************************
# Spare Part ID
#**********************************************
ID0 <- 1055
dftsnz <- filter(tbio, ID == ID0 & Movement == "OUT") %>% arrange(Date)
ldays <- seq(min(dftsnz$Date), max(dftsnz$Date), by = "day")
tsid0 <- data.frame(Quantity = rep(0, length(ldays)))
rownames(tsid0) <- as.character(ldays)
tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE)
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE)
help("hist")
hist(colSums(mcsimts), freq=FALSE, breaks=max(colSums(mcsimts)))
# Simulate Intermittent demand
library(tsintermittent)
library(dplyr)
library(markovchain)
compu <- "MAC"               # Are you running the code in Windows or Mac?
if (compu == "PC") {
Sys.setenv(R_ZIPCMD= "C:/Rtools/bin/zip")
dpath <- "C:/Users/L01032102/Google Drive/Capacitacion/6S Green Belt/SPINVI"
} else {
dpath <- "/Users/Pach/Google Drive/Capacitacion/6S Green Belt/SPINVI"
}
load(file = paste(dpath, "/Datos/R/tbml.RData", sep=""))
load(file = paste(dpath, "/Datos/R/tbio.RData", sep=""))
#############################################
# Functions
#############################################
#**********************************************
# Spare Part ID
#**********************************************
ID0 <- 1055
dftsnz <- filter(tbio, ID == ID0 & Movement == "OUT") %>% arrange(Date)
ldays <- seq(min(dftsnz$Date), max(dftsnz$Date), by = "day")
tsid0 <- data.frame(Quantity = rep(0, length(ldays)))
rownames(tsid0) <- as.character(ldays)
tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE, breaks=max(colSums(simts)))
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE, breaks=max(colSums(mcsimts)))
# Simulate Intermittent demand
library(tsintermittent)
library(dplyr)
library(markovchain)
compu <- "MAC"               # Are you running the code in Windows or Mac?
if (compu == "PC") {
Sys.setenv(R_ZIPCMD= "C:/Rtools/bin/zip")
dpath <- "C:/Users/L01032102/Google Drive/Capacitacion/6S Green Belt/SPINVI"
} else {
dpath <- "/Users/Pach/Google Drive/Capacitacion/6S Green Belt/SPINVI"
}
load(file = paste(dpath, "/Datos/R/tbml.RData", sep=""))
load(file = paste(dpath, "/Datos/R/tbio.RData", sep=""))
#############################################
# Functions
#############################################
#**********************************************
# Spare Part ID
#**********************************************
ID0 <- 2756
dftsnz <- filter(tbio, ID == ID0 & Movement == "OUT") %>% arrange(Date)
ldays <- seq(min(dftsnz$Date), max(dftsnz$Date), by = "day")
tsid0 <- data.frame(Quantity = rep(0, length(ldays)))
rownames(tsid0) <- as.character(ldays)
tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE, breaks=max(colSums(simts)))
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE, breaks=max(colSums(mcsimts)))
q()
# Simulate Intermittent demand
library(tsintermittent)
library(dplyr)
library(markovchain)
compu <- "MAC"               # Are you running the code in Windows or Mac?
if (compu == "PC") {
Sys.setenv(R_ZIPCMD= "C:/Rtools/bin/zip")
dpath <- "C:/Users/L01032102/Google Drive/Capacitacion/6S Green Belt/SPINVI"
} else {
dpath <- "/Users/Pach/Google Drive/Capacitacion/6S Green Belt/SPINVI"
}
load(file = paste(dpath, "/Datos/R/tbml.RData", sep=""))
load(file = paste(dpath, "/Datos/R/tbio.RData", sep=""))
#############################################
# Functions
#############################################
#**********************************************
# Spare Part ID
#**********************************************
ID0 <- 2756
dftsnz <- filter(tbio, ID == ID0 & Movement == "OUT") %>% arrange(Date)
ldays <- seq(min(dftsnz$Date), max(dftsnz$Date), by = "day")
tsid0 <- data.frame(Quantity = rep(0, length(ldays)))
rownames(tsid0) <- as.character(ldays)
tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE, breaks=max(colSums(simts)))
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE, breaks=max(colSums(mcsimts)))
q()
# Simulate Intermittent demand
library(tsintermittent)
library(dplyr)
library(markovchain)
compu <- "MAC"               # Are you running the code in Windows or Mac?
if (compu == "PC") {
Sys.setenv(R_ZIPCMD= "C:/Rtools/bin/zip")
dpath <- "C:/Users/L01032102/Google Drive/Capacitacion/6S Green Belt/SPINVI"
} else {
dpath <- "/Users/Pach/Google Drive/Capacitacion/6S Green Belt/SPINVI"
}
load(file = paste(dpath, "/Datos/R/tbml.RData", sep=""))
load(file = paste(dpath, "/Datos/R/tbio.RData", sep=""))
#############################################
# Functions
#############################################
#**********************************************
# Spare Part ID
#**********************************************
ID0 <- 2756
dftsnz <- filter(tbio, ID == ID0 & Movement == "OUT") %>% arrange(Date)
ldays <- seq(min(dftsnz$Date), max(dftsnz$Date), by = "day")
tsid0 <- data.frame(Quantity = rep(0, length(ldays)))
rownames(tsid0) <- as.character(ldays)
tsid0$Quantity[ldays %in% dftsnz$Date] <- dftsnz$Quantity
N <- 28
NTS <- 1000
#**********************************************
# Simulate lead time distribution (CROSTON)
#**********************************************
adi0 <- as.numeric(mean(diff(dftsnz$Date)))
level0 <- mean(dftsnz$Quantity)
cv02 <- with(dftsnz, sd(Quantity)/mean(Quantity))
simts <- simID(n=NTS, obs=N, idi=adi0, cv2=cv02, level=level0)
hist(colSums(simts), freq=FALSE, breaks=max(colSums(simts)))
fts <- crost(as.numeric(tsid0$Quantity), h=28, outplot=TRUE, type="sba", nop=1)
#**********************************************
# Simulate lead time distribution (WILLEMAIN & SMART)
#*********************************************
tsid1 <- rep(0, length(tsid0$Quantity))
tsid1[tsid0$Quantity >0] <- 1
mcfit <- markovchainFit(as.character(tsid1))
mcsimts <- matrix(0, nrow=N, ncol=NTS)
for (j in 1:NTS) {
x <- rmarkovchain(n=N, object=mcfit$estimate)
fxp <- x > 0
x[fxp] <- sample(tsid0$Quantity[tsid0$Quantity>0], size=sum(fxp), replace=TRUE)
y <- as.numeric(x)
y[fxp] <- 1 + trunc(y[fxp] + rnorm(sum(fxp))*sqrt(y[fxp]))
y[y<=0] <- as.numeric(x[y<=0])
mcsimts[,j] <- y
}
hist(colSums(mcsimts), freq=FALSE, breaks=max(colSums(mcsimts)))
q()
100/12
11*8.5
11*8.5+6.5
library(MEMS)
data("dbife")
library(dplyr)
df <- filter(dbife, lista_nominal < 200)
nrow(df)
nrow(dbife)
df
sum(df$lista_nominal)
df$VOTA1/sum(df$VOTA)
sum(df$VOTA1)/sum(df$VOTA)
sum(df$VOTA2)/sum(df$VOTA)
sum(df$VOTA3)/sum(df$VOTA)
sum(df$VOTA4)/sum(df$VOTA)
q()
help(hiper)
help(phyper)
dhyper(0, 4, 14, 2)
help(dbinom)
pbinom(10, 12, .8)
pbinom(12, 12, .8)
pbinom(10, 12, .2)
pbinom(10, 12, .8)
dbinom(10, 12, .8)
dbinom(2, 12, .8)
dbinom(2, 12, .2)
dbinom(2, 10, .2)
sin(1)
sin(pi/2)
1-sin(1)
37+6.5+9+12.5
24+12.5
22.5+17+25
25+22.5+50
q()
990*2
q()
q()
8*3
60*24
8*3*1440
8*3*1440*.5*.5
q()
8880/4
q()
library(ggmap)
help("ggmap")
violent_crimes <- subset(crime,
offense != "auto theft" &
offense != "theft" &
offense != "burglary"
)
head(violent_crimes)
levels(violent_crimes$offense)
violent_crimes$offense <-
factor(violent_crimes$offense,
levels = c("robbery", "aggravated assault",
"rape", "murder")
)
levels(violent_crimes$offense)
violent_crimes <- subset(violent_crimes,
-95.39681 <= lon & lon <= -95.34188 &
29.73631 <= lat & lat <=  29.78400
)
theme_set(theme_bw(16))
HoustonMap <- qmap("houston", zoom = 14, color = "bw",
extent = "device", legend = "topleft")
HoustonMap <- ggmap(
get_map("houston", zoom = 14, color = "bw"),
extent = "device", legend = "topleft"
)
HoustonMap +
geom_point(aes(x = lon, y = lat, colour = offense, size = offense), data = violent_crimes) +
scale_colour_discrete("Offense", labels = c("Robery","Aggravated Assault","Rape","Murder")) +
scale_size_discrete("Offense", labels = c("Robery","Aggravated Assault","Rape","Murder"),
range = c(1.75,6)) +
guides(size = guide_legend(override.aes = list(size = 6))) +
theme(
legend.key.size = grid::unit(1.8,"lines"),
legend.title = element_text(size = 16, face = "bold"),
legend.text = element_text(size = 14)
) +
labs(colour = "Offense", size = "Offense")
head(violent_crimes)
help("stat_density2d")
help(aes)
HoustonMap +
stat_density2d(aes(x = lon, y = lat, colour = offense),
size = 3, bins = 2, alpha = 3/4, data = violent_crimes) +
scale_colour_discrete("Offense", labels = c("Robery","Aggravated Assault","Rape","Murder")) +
theme(
legend.text = element_text(size = 15, vjust = .5),
legend.title = element_text(size = 15,face="bold"),
legend.key.size = grid::unit(1.8,"lines")
)
HoustonMap +
stat_density2d(aes(x = lon, y = lat, fill = ..level.., alpha = ..level..),
size = 2, bins = 4, data = violent_crimes, geom = "polygon") +
scale_fill_gradient("Violent\nCrime\nDensity") +
scale_alpha(range = c(.4, .75), guide = FALSE) +
guides(fill = guide_colorbar(barwidth = 1.5, barheight = 10))
summary(violent_crimes)
library(MASS)
data(geyser)
head(geyser)
str(geuser)
str(geyser)
help("stat_density2d")
q()
q()
shiny::runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
help("sidebarPanel")
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
help("theme")
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
help("geom_point")
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
casillas <- read.table(file = "data/Ubicacion Casillas Exit Poll.csv", header = TRUE,
sep = ",")
getwd()
setwd("~/Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll")
casillas <- read.table(file = "data/Ubicacion Casillas Exit Poll.csv", header = TRUE,
sep = ",")
head(casillas)
runApp('~/Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
help(aes)
runApp('~/Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
runApp('~/Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_exit_poll')
q()
shiny::runApp()
runApp()
runApp('C:/Users/L01032102/Google Drive/Investigación/Encuestas/Geoelectoral/apps/mapa_gob16_part')
